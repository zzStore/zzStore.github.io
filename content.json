[{"title":"1-Springcloud版本介绍","date":"2020-08-13T08:40:26.000Z","path":"2020/08/13/1-Springcloud版本介绍/","text":"版本上篇 SpringBoot2.X版+SpringCloud H 版下篇 SpringCloud Alibaba官网查看 cloud与boot 版本对应关系https://spring.io/projects/spring-cloud#overflow 更加详细的cloud与boot版本对应https://start.spring.io/actuator/info","tags":[]},{"title":"2-Springcloud项目实践","date":"2020-08-13T08:40:21.000Z","path":"2020/08/13/2-Springcloud项目实践/","text":"新建父项目 新建maven工程 选择模板 org.apache.maven.archetypes:maven-archetypes-site 选择项目字符编码setting-&gt;editor-&gt;file Encodings -&gt;将所有字符编码全部换成 utf-8 支持注解setting-&gt;Build,Execution,Deployment-&gt;Compiler-&gt;Annotation Processors 内的 Enable annotation processing 打上勾表示能够使用注解。 更改编译版本setting-&gt;Build,Execution,Deployment-&gt;Compiler-&gt;Java Compiler 下 Pe-module butecode version 框内的编译版本换成 8 删除src文件夹 父工程POMmaven中的 dependencyManagement 与 dependenciesdependencyManagement 父类管理Maven 使用dependencyManagement元素提供依赖版本号管理的方式==通常会在一个组织或者项目的最顶级父POM中看到dependencyManagement == 使用dependencyManagement可以使所有子项目中引用一个依赖而不用显示列出版本号。Maven会沿父子层级向上走，直到找到dependencyManagement元素的项目 ，然后它就会使用版本号 如果某一个子项目需要另外一个版本，加上version即可。如果子项目中声明了版本号，那么使用子项目中的jar包。 dependencyManagement只是声明依赖，并不实现引入，一次子项目需要显式的声明需要用的依赖。 支付模块构建1. cloud-provider-payment8001微服务提供者支持Moudle模块 建module 新建maven工程，不使用任何模板，改jdk为1.8。 写入项目name即可。 改POM 主POM内增加 moudle 子项目引入依赖 写YML 主启动 业务类2. 热部署Devtools 引入坐标依赖 1234567 &lt;!--热部署--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 添加插件到父类总工程中 12345678910111213&lt;build&gt; &lt;finalName&gt;工程名字&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 开启自动编译权限setting-&gt;Build,Execution,Deployment-&gt;Compiler 内复选框全部打勾 开启热注册 进入子模块 ctrl shift alt / 选择 Registry compiler.automake.allow.when.app.running compiler.automake.allow.when.app.running 这两个勾选中 重启idea 3. cloud-consumer-order80微服务消费者订单Module模块 建module 新建maven工程，不使用任何模板，改jdk为1.8。 写入项目name即可。 改POM 主POM内增加 moudle 子项目引入依赖 写YML 主启动 业务类 将第一个子模块支付模块的实体类包复制过来 新建Controller类 使用 RestTemplate 进行两个模块之间的调用，由消费者订单模块调用支付模块。 新建配置类，注册 RestTemplate bean 1234567@Configurationpublic class ApplicationContextConfig &#123; @Bean public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; 写Controller方法 12345678910111213141516public class OrderController &#123; public static final String PAYMENT_URL = \"http://localhost:8001\"; @Resource private RestTemplate restTemplate; @GetMapping(\"/consumer/payment/create\") public CommonResult&lt;Payment&gt; create(Payment payment)&#123; return restTemplate.postForObject(PAYMENT_URL+\"/payment/create\",payment,CommonResult.class); &#125; @GetMapping(\"/consumer/payment/get/&#123;id&#125;\") public CommonResult&lt;Payment&gt; getPayment(@PathVariable(\"id\")Long id)&#123; return restTemplate.getForObject(PAYMENT_URL+\"/payment/get/\"+id,CommonResult.class); &#125;&#125; 启动 先启动8001 再启动 80 idea右下角弹出窗口，选择show，共同管理两个端口号 使用http://localhost/consumer/payment/get/31访问，80为默认端口号可省略不写 工程重建： 问题项目中有重复部分：两个工程中有完全相同的实体类 新建公共项目 cloud-api-commons 将公共有的实体类包括工具类等放到里面，所有模块都可以使用 导入依赖 lombok devtools 以及 hutool 工具包 将实体类包导入到项目中 maven clean install 点击上面的闪电 跳过测试 进入 maven 找到新建模块，进入 Lifecycle 先clean再 install重新安装 注意观察公共模块 pom 文件中必须含有独立的 groupid 和 artifactid","tags":[]},{"title":"3-Eureka","date":"2020-08-13T08:39:09.000Z","path":"2020/08/13/3-Eureka/","text":"Eureka基础知识什么是服务注册Eureka Server 作为服务注册功能的服务器，它是服务注册中心，而系统中其他微服务，使用 Eureka 的客户端连接到 Eureka Server 并维持心跳连接，这样系统维护人员就可以通过 Eureka Server来监控各个微服务是否正常运行。 在服务注册与发现中有一个注册中心，服务器启动时，会把当前自己的服务器信息比如服务地址，通信地址等注册到注册中心上，另一方（消费者）以别名的方式在注册中心上获取实际的服务器通讯地址，然后再实现本地RPC调用远程RPC。 Eureka的两个组件 Eureka Server 提供服务注册服务各个微服务节点通过配置启动后，会在 EurekaServer中进行注册，这样 EurekaServer中的服务注册表中将会存储所有可用服务节点的信息。 EurekaClient通过注册中心进行访问是一个Java客户端，用于简化与 Eureka Server的交互，客户端也同时具备一个内置的，使用 轮询负载算法的负载均衡器。在应用启动后，将会向Eureka Server 发送心跳（默认周期30秒）。如果Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中将这个服务节点移除（默认90秒） 单机EurekaIDEA生成eurekaServer端服务注册中心，类似物业公司 建Modulecloud-eureka-server7001 改pom 12345678910111213141516171819202122232425262728293031323334353637&lt;dependencies&gt; &lt;!--eureka-server--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--引入自己的公共api--&gt; &lt;dependency&gt; &lt;groupId&gt;com.wxh.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--热部署--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 写YML 12345678910111213server: port: 7001eureka: instance: hostname: localhost # eureka服务端实例名称 client: #false表示不向注册中心注册自己 register-with-eureka: false #false表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务 fetch-registry: false service-url: # 设置与 eureka server交互的地址查询服务和注册服务都需要依赖这个地址 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 主启动 12345678@SpringBootApplication// 声明自己是 eureka 的服务端@EnableEurekaServerpublic class EurekaMain7001 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaMain7001.class,args); &#125;&#125; 测试浏览器进入 http://localhost:7001/ 看能不能看到 eureka 的服务页面 EurekaClient端cloud-provider-payment8001 将注册进 EurekaServer 成为服务提供者 provider ，类似尚硅谷对外提供授课服务 引入坐标依赖 12345&lt;!--eureka-client--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 更改yml配置 12345678eureka: client: #表示是否将自己注册进EurekaServer默认为true register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用 负载均衡 fetch-registry: false service-url: defaultZone: http://localhost:7001/eureka 添加注解8001启动类添加@EnableEurekaClient注解 测试进入http://localhost:7001/可以看到DS ReplicasInstances currently registered with Eureka 下的服务端口EurekaClient端 cloud-consumer-order80注册进EurekaServer成为服务注册者consumer，类似来尚硅谷上课的同学步骤同上集群Eureka构建步骤集群的目的高可用，如果注册中心只有一个，出了故障就会导致整个服务环境不可用解决方法：搭建Eureka注册中心集群，实现负载均衡+故障排错 多个 eureka serve 相互注册，保障信息共享。 搭建集群 将7001模块复制 粘贴后修改 pom 文件，yml文件，主启动类 在主 pom 文件中的 moudles 中加入 7002 即可集群与单机的区别 修改映射文件找到 C:\\Windows\\System32\\drivers\\etc 下的 hosts文件添加127.0.0.1 eureka7001.com127.0.0.1 eureka7002.com yml 文件 12345678# 仅写修改的部分eureka: instance: hostname: eureka7001.com # eureka服务端实例名称，集群名字要不同有区分 client: service-url: # 设置与 eureka server交互的地址查询服务和注册服务都需要依赖这个地址，因为两台集群所以相互注册 defaultZone: http://eureka7002.com:7002/eureka/ 测试访问http://eureka7001.com:7001/http://eureka7002.com:7002/可以看到两者相互注册 问题三台集群如何相互守望注册把微服务模块 payment 与 order 发布到 eureka 集群上 修改两个模块的pom文件defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7001.com:7001/eureka/ 测试，启动微服务 7001/7002 8001 80 http://localhost/consumer/payment/get/34支付模块微服务的集群配置 复制模块8001，更改端口为8002 修改 8001与8002的controller 123// 在各个方法中调用 serverPort 查看端口号@Value(\"$&#123;server.port&#125;\")private String serverPort; 修改 80 中controller的PAYMENT_URL 在之前单机版中写死为8001，但是集群后有8001与8002， 进入 http://eureka7001.com:7001/ 查看 8001 与 8002 对应的名称 application 将 PAYMENT_URL 改为 http+application 名 :http://CLOUD-PAYMENT-SERVICE 此时未开启负载均衡不能访问页面：将80端口下的配置类ApplicationContextConfig 下生成的 RestTemplate 的bean方法上添加注解 @LoadBalanced http://localhost/consumer/payment/get/34 访问查看端口号，可以看到在8001与8002之间来回切换actuator微服务信息完善修改主机名与暴露ip地址可在http://eureka7002.com:7002/ 查看自定义主机名的变化鼠标在主机名上方，浏览器下面会出现ip地址1234eureka instance: instance-id: payment8002 # 自定义主机名 prefer-ip-address: true # 设置暴露ip地址 服务发现Discovery 8001 的 controller添加代码 123456789101112131415161718@Resourceprivate DiscoveryClient discoveryClient;@GetMapping(\"/payment/discovery\")public DiscoveryClient discovery()&#123; // 得到所有服务名 List&lt;String&gt; services = discoveryClient.getServices(); services.forEach(ele-&gt;&#123; log.info(\"***service***\"+ele); &#125;); // 得到服务名对应的信息 List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(\"CLOUD-PAYMENT-SERVICE\"); instances.forEach(ele-&gt;&#123; log.info(ele.getServiceId()+\"\\t\"+ele.getHost()+\"\\t\"+ele.getPort()+\"\\t\"+ele.getUri()); &#125;); return discoveryClient;&#125; 8001 主类添加注解 @EnableDiscoveryClient 重启服务，观察日志 eureka自我保护自我保护理论 为什么会产生自我保护？为了防止 EurekaClient 可以正常运行，但是在 EurekaServer 网络不通的情况下，EurekaServer 不会立刻将 EurekaClient 服务剔除。 什么是自我保护模式？默认情况下，EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例（默认90s），但是当网络分区故障发生，微服务与 EurekaServer 之间无法正常通信，以上行为就非常危险。当EurekaServer节点在短时间内丢失过多客户端时，那么这个节点就会进入自我保护模式。禁止自我保护 将 7001 与 8001 改为单机版：修改对应 eureka 地址 yml文件 123456789101112131415# 7001eureka: server: # 关闭自我保护机制 enable-self-preservation: false # 心跳时间默认90s，改为2000ms，即2s eviction-interval-timer-in-ms: 2000# 8001eureka: instance: #eureka客户端发送心跳的时间间隔，默认30s lease-renewal-interval-in-seconds: 1 #eureka服务端在收到最后一次心跳等待的时间上线，默认90s lease-expiration-duration-in-seconds: 2 测试 访问 http://eureka7001.com:7001/ 可以看到红字THE SELF PRESERVATION MODE IS TURNED OFF. THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.代表自我保护关闭 关闭8001服务可以看到在 eureka 页面两秒后 8001 服务消失","tags":[]},{"title":"4-Zookeeper","date":"2020-08-13T08:38:59.000Z","path":"2020/08/13/4-Zookeeper/","text":"配置虚拟机和zookeeper 虚拟机终端输入ifconfig查看 ens33 下的端口号 查看主机与虚拟机之间通信是否畅通 虚拟机端口号：ifconfig查看 ens33 下的端口号 主机端口号：网络连接下的 VMnet8 的端口号 使用虚拟机ping主机，使用主机ping虚拟机确保都可以ping通 新建项目 pom 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 解压zookeeper#tar -zxvf zookeeper-3.4.10.tar.gz 启动 zookeeper==注意此时应该修改conf里的zoo_sample.cfg名字为zoo.cfg==[root@localhost ~]# cd /usr/local/zookeeper/zookeeper-3.4.14/bin[root@localhost bin]# ./zkServer.sh start 启用端口[root@localhost bin]# ./zkCli.shConnecting to localhost:2181新建项目pom文件==注意：== 排除zookeeper-discovery中自带的 zookeeper，同时引入与linux相同版本的 zookeeper 排除引入 zookeeper 的日志，因为日志会会冲突1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;dependencies&gt; &lt;!--引入自己的公共api--&gt; &lt;dependency&gt; &lt;groupId&gt;com.wxh.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--热部署--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt; &lt;!-- 排除自身的zookeeper --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- 添加zookeeper,与linux上的版本一致 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; yml 文件12345678910server: port: 8004spring: application: name: cloud-provider-payment cloud: zookeeper: # ip地址为linux中的网络接口，2181为zookeeper的默认端口 connect-string: 192.168.150.66:2181 linux测试12[zk: localhost:2181(CONNECTED) 3] ls /services[cloud-provider-payment] 能看到服务名即为配置成功 测试2 http://localhost:8004/payment/zk可以看到信息 linux 123456789# 获取服务名[zk: localhost:2181(CONNECTED) 0] ls /services[cloud-provider-payment]# 获取流水号[zk: localhost:2181(CONNECTED) 1] ls /services/cloud-provider-payment[efc76371-522d-4d5d-8f56-f8fe4deb7a47]# 获取详细信息[zk: localhost:2181(CONNECTED) 2] get /services/cloud-provider-payment/efc76371-522d-4d5d-8f56-f8fe4deb7a47&#123;&quot;name&quot;:&quot;cloud-provider-payment&quot;,&quot;id&quot;:&quot;efc76371-522d-4d5d-8f56-f8fe4deb7a47&quot;,&quot;address&quot;:&quot;WINDOWS-N0GUAG7&quot;,&quot;port&quot;:8004,&quot;sslPort&quot;:null,&quot;payload&quot;:&#123;&quot;@class&quot;:&quot;org.springframework.cloud.zookeeper.discovery.ZookeeperInstance&quot;,&quot;id&quot;:&quot;application-1&quot;,&quot;name&quot;:&quot;cloud-provider-payment&quot;,&quot;metadata&quot;:&#123;&#125;&#125;,&quot;registrationTimeUTC&quot;:1590232919360,&quot;serviceType&quot;:&quot;DYNAMIC&quot;,&quot;uriSpec&quot;:&#123;&quot;parts&quot;:[&#123;&quot;value&quot;:&quot;scheme&quot;,&quot;variable&quot;:true&#125;,&#123;&quot;value&quot;:&quot;://&quot;,&quot;variable&quot;:false&#125;,&#123;&quot;value&quot;:&quot;address&quot;,&quot;variable&quot;:true&#125;,&#123;&quot;value&quot;:&quot;:&quot;,&quot;variable&quot;:false&#125;,&#123;&quot;value&quot;:&quot;port&quot;,&quot;variable&quot;:true&#125;]&#125;&#125; 服务节点是临时还是持久关闭8004后在linux终端中,一段时间后失去连接123456789[zk: localhost:2181(CONNECTED) 18] ls /services/cloud-provider-payment[efc76371-522d-4d5d-8f56-f8fe4deb7a47][zk: localhost:2181(CONNECTED) 19] ls /services/cloud-provider-payment[efc76371-522d-4d5d-8f56-f8fe4deb7a47][zk: localhost:2181(CONNECTED) 20] ls /services/cloud-provider-payment[efc76371-522d-4d5d-8f56-f8fe4deb7a47][zk: localhost:2181(CONNECTED) 21] ls /services/cloud-provider-payment[][zk: localhost:2181(CONNECTED) 22] 再开启8004，再次查看流水号可以发现流水号跟之前的不一样 ，所以服务节点是临时的，在关闭服务后完全删除。 订单服务入住zookeeper 新建订单 moudle 该pom 建yml 12345678server: port: 80spring: application: name: cloud-consumerzk-order80 cloud: zookeeper: connect-string: 192.168.150.66:2181 写主类 配置类生成 RestTemplate Controller 调用 8004 linux 输入，查看节点是否注册上 12[zk: localhost:2181(CONNECTED) 1] ls /services[cloud-provider-payment, cloud-consumerzk-order80] 网址登陆查看http://localhost:8004/payment/zkhttp://localhost/consumer/payment/zk 存在问题zookeeper集群?????????","tags":[]},{"title":"5-Consul","date":"2020-08-13T08:38:49.000Z","path":"2020/08/13/5-Consul/","text":"简介是什么？https://www.consul.io/introConsul是一种服务网格解决方案，提供具有服务发现，配置和分段功能的全功能控制平面。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建完整的服务网格。Consul需要一个数据平面，并支持代理和本机集成模型。Consul附带了一个简单的内置代理，因此一切都可以直接使用，还支持Envoy等第三方代理集成。 能做什么？ 服务发现：Consul的客户端可以注册服务，例如 api或mysql，其他客户端可以使用Consul来发现给定服务的提供者。使用DNS或HTTP，应用程序可以轻松找到它们依赖的服务。 运行状况检查：领事客户端可以提供任何数量的运行状况检查，这些检查可以与给定服务（“ Web服务器返回200 OK”）或与本地节点（“内存利用率低于90％”）相关联。操作员可以使用此信息来监视群集的运行状况，服务发现组件可以使用此信息将流量路由到运行状况不佳的主机之外。 KV商店：应用程序可以将Consul的分层键/值存储用于多种目的，包括动态配置，功能标记，协调，领导者选举等。简单的HTTP API使其易于使用。 安全的服务通信：领事可以为服务生成并分发TLS证书，以建立相互TLS连接。 意图 可用于定义允许哪些服务进行通信。可以使用可以实时更改的意图轻松管理服务分段，而不必使用复杂的网络拓扑和静态防火墙规则。 多数据中心：Consul开箱即用地支持多个数据中心。这意味着Consul的用户不必担心会构建其他抽象层以扩展到多个区域。 去哪下？https://www.consul.io/downloads 怎么玩？https://www.springcloud.cc/spring-cloud-consul.html 安装启动 将下载的exe文件双击即可安装 在 exe ==文件的目录==下打开黑窗口 输入 consul –version 检测是否安装成功 启动服务：consul agent -dev 通过 http://localhost:8500/ 访问web界面服务提供者 改pom 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 建yml 1234567891011server: port: 8006spring: application: name: cloud-provider-payment cloud: consul: host: localhost port: 8500 discovery: service-name: $&#123;spring.application.name&#125; 建启动类 建controller类 测试http://localhost:8006/payment/consulhttp://localhost:8500/ui/dc1/services服务消费者 改pom 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 建yml 1234567891011server: port: 80spring: application: name: cloud-consumer-order cloud: consul: host: localhost port: 8500 discovery: service-name: $&#123;spring.application.name&#125; 建启动类 建controller 测试http://localhost/consumer/payment/cshttp://localhost:8006/payment/consul三个注册中心 eureka zookeeper consul的异同点 CAPC:Cosistency（强一致性）A:Availability（可用性）P:Partition tolerance（分区容错性）CAP理论关注粒度是数据，而不是整体系统设计的","tags":[]},{"title":"6-Ribbon","date":"2020-08-13T08:38:40.000Z","path":"2020/08/13/6-Ribbon/","text":"概述是什么？Spring Cloud Ribbon 是基于 Netflix Ribbon 实现的一套==客户端负载均衡的工具==。简单的说，Ribbonn是Netflix的开源项目，主要功能 是提供==客户端的软件负载均衡算法和服务调用。==Ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等。就是在配置文件中列出 Loa Balancer后面所有机器，Ribbon会自动帮助你基于某种规则 (如简单轮询，随机连接等)去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。 官网资料，停更https://github.com/Netflix/ribbon 能干什么？ 负载均衡 负载均衡(Load Balance)是什么 将用户的请求平摊的分配到多个服务上，从而达到HA(高可用)，常见的负载均衡有 Nginx,LVS,硬件 F5等。 Ribbon 本地负载均衡客户端 VS Nginx 服务端负载均衡 Nginx 是服务器 负载均衡，客户端所有请求都会交给 nginx，然后由 nginx实现请求转发。即负载均衡是由服务端实现的。 Ribbon 是本地负载均衡，在微服务调用接口时，在注册中心上获取注册信息服务列表 之后缓存在JVM本地，从而实现本地RPC远程服务调用技术。 实现负载均衡+RestTemplate 调用 Ribbon工作时有两步 第一步先选择 EurekaServer，优先选择统一区域负载较少的 server 第二部再根据用户指定的策略，从server取到的服务注册列表中选择一个地址。其中 Riibon 提供了多种策略（轮询，随机，根据响应时间加权）。 引入依赖不需要spring-cloud-starter-netflix-eureka-client 已经引入了 Ribbon-Balance的依赖 RestTemplate 使用 getForObject 返回json getForEntity 返回ResponseEnity对象，包括响应头，响应体等信息。 postForObject与 get 方法一样，不同的是传进去的参数是对象 postForEntity GET 请求方法 POST请求方法 Ribbon 自带的负载均衡核心组件 IRuleIRule默认自带的负载规则 RoundRobinRule 轮询 RandomRule 随机 RetryRule 先按照RoundRobinRule的 策略获取服务，如果获取服务失败则在指定时间里进行重试，获取可用服务 WeightedResponseTimeRule 对RoundRobinRule的扩展，响应速度越快，实例选择权重越大 ，越容易被选择 BestAvailableRule 会先过滤掉由于多次访问故障而处于断路器 跳闸状态的服务，然后选择一个并发一个最小的服务 BestAvaibilityFilteringRule 先过滤掉故障实例，再选择并发量较小的实例 ZoneAvoidanceRule 默认规则，符合server所在区域的性能和server的可用性选择服务器如何替换 注意：IRule配置类不能放在@ComponentSan 的包及子包下，因为默认的扫描会变成全局负载均衡都按照这样的规则。 新建包 com.wxh.myRule 新建类 123456public class MySelfRule &#123; @Bean public IRule myRule()&#123; return new RandomRule();//定义为随机 &#125;&#125; 主类添加注解 12// 选择要接收的服务和配置类@RibbonClient(name = \"CLOUD-PAYMENT-SERVICE\",configuration = MySelfRule.class) 默认负载均衡轮回算法原理负载均衡算法rest 接口 第几次请求数 % 服务器集群=实际调用服务器位置下标，每次服务重启后rest接口计数从1开始 总台数：2台 请求数 调用下标1 1%2=12 2%2=03 3%2=14 4%2=0 RoundRobinRule源码分析跳过41集 手写轮回算法跳过42集","tags":[]},{"title":"7-OpenFeign","date":"2020-08-13T08:38:23.000Z","path":"2020/08/13/7-OpenFeign/","text":"是什么Feign是声明性Web服务客户端。它使编写Web服务客户端更加容易。要使用Feign，请创建一个接口并对其进行注释。它具有可插入的注释支持，包括Feign注释和JAX-RS注释。Feign还支持可插拔编码器和解码器。Spring Cloud添加了对Spring MVC注释的支持，并支持使用HttpMessageConvertersSpring Web中默认使用的注释。Spring Cloud集成了Ribbon和Eureka以及Spring Cloud LoadBalancer，以在使用Feign时提供负载平衡的http客户端。 能干什么 使编写Java Http客户端更加容易使用 RestTemplate+Ribbon 时，利用 RestTemplate 对http 请求的封装处理，形成一套模板化的调用方法，但是在实际中，由于对服务的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以Feign在此基础上做了进一步封装，由他来帮助我们定义和实现服务接口的定义。在==Feign的实现下我们只需要创建一个接口并使用注解来配置它(以前是Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可)==。自动封装服务调用客户端的开发量。 Feign集成了Ribbon利用Ribbon维护了Payment的服务列表信息，并且实现了轮询实现客户端的负载均衡。而与Ribbon不同的是，==feign只需要定义服务绑定接口且以声明式的方法==，优雅而简单的实现服务调用。 Feign与OpenFeign区别 官网https://cloud.spring.io/spring-cloud-openfeign/2.2.x/reference/html/ 建项目：cloud-consumer-frign-order80 改pom 建yml 写启动类 1234567@SpringBootApplication@EnableFeignClientspublic class OrderFeignMain80 &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderFeignMain80.class,args); &#125;&#125; 写业务类 123456789@Component// 将业务提供者的名写进去@FeignClient(value = \"CLOUD-PAYMENT-SERVICE\")public interface PaymentFeignService &#123;// 将业务提供者的controller路径和方法复制粘贴进来 @GetMapping(\"/payment/get/&#123;id&#125;\") public CommonResult getPaymentById(@PathVariable(\"id\")Long id);&#125; controller 1234@GetMapping(\"/consumer/payment/get/&#123;id&#125;\")public CommonResult&lt;Payment&gt; getPaymentById(@PathVariable Long id)&#123; return paymentFeignService.getPaymentById(id);&#125; 超时控制 8001 暂停 通过 8001访问http://localhost:8001/timeout可以访问 通过80 访问异常 OpenFeign 默认等待时间 1s 设置超时时间 测试日志增强日志级别 NONE：默认不显示日志 BASIC：仅记录请求方法，URL，响应状态及执行时间 HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息 FULL：除了HEADERS中定义的信息外，还有请求和响应的正文及元数据配置类123456789import feign.Logger;@Configurationpublic class FeignConfig &#123; @Bean Logger.Level feignLoggerLevel()&#123; return Logger.Level.FULL; &#125;&#125; 选择日志监听接口1234logging: level: # 选择具体接口的日志输出 级别为debug com.wxh.springcloud.service.PaymentFeignService: debug","tags":[]},{"title":"8-Hystrix","date":"2020-08-13T08:38:11.000Z","path":"2020/08/13/8-Hystrix/","text":"简介分布式系统面临的问题复杂分布式系统中的应用程序有数十个依赖关系，每个依赖关系在某些时候不可避免的失败。 多个微服务之间调用时，假设 A 调B和C，B和C又调其他微服务，就是所谓的扇出。当扇出的链路上某个微服务响应时间过长或不可用对A的调用就会占用越来越多的资源，进而引起系统崩溃 ，所谓的雪崩效应。 是什么Hystrix 是处理分布式系统的延迟和容错的开源库，保证一个依赖出现问题时不会导致整体服务失败，避免级联故障，以提高分布式系统弹性。断路器本身是一种开关装置，当某个服务单元发生故障后，通过断路器的故障监控，向调用方返回一个符合预期的可处理的备选响应，而不是长时间的等待或抛出调用方法无法处理的异常 。 官网资料https://github.com/Netflix/Hystrix停更 Hystrix重要概念服务降级 服务器忙，请稍后重试，不让客户端等待并立即返回一个友好的提示。 哪些情况会导致服务降级 程序运行异常 超时 服务熔断触发服务降级 线程池/信号量打满服务熔断 类比保险丝达到最大服务访问时，直接拒绝访问，拉闸限电，然后调用服务降级的方法返回友好提示。 服务降级-&gt;进而熔断-&gt;恢复调用链路服务限流 秒杀高并发等操作，严禁一窝蜂过来拥挤，一秒N个有序进行。案例准备cloud-provider-hystrix-payment8001将 7001换成单机版构建 新建 pom 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; yml 123456789101112server: port: 8001spring: application: name: cloud-provider-hystrix-paymenteureka: client: register-with-eureka: true fetch-registry: true service-url: defauleZone: http://eureka7001.com:7001/eureka 主启动 业务类 测试先启动7001，在启动8001测试两个方法，全部正常使用Jmeter模拟高并发51集高并发打到http://localhost:8001/timeout/1上使用后http://localhost:8001/ok/1 也有延迟上述还是8001单独测试，如果外部消费者80也来访问，那么消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖死。加入80 建moudle cloud-consumer-feign-hystrix-order80 pom yml 主启动类 service controller 测试 正常情况下 http://localhost:8001/ok/1 http://localhost:8001/timeout/1 http://localhost/ok/1 通过80 访问的非常快 高并发打到8001端口时,80端口也会非常慢如何解决 超时导致服务器变慢（转圈）-&gt;超时不再等待 出错（宕机或程序运行时出错）-&gt;出错要有兜底 解决 8001 超时，调用者 80 不能一直等待，必须有服务降级 服务 8001 宕机，调用者 80 不能一直等待，必须有服务降级 服务 8001 OK ，调用者自己出故障或有自我要求（自己的等待时间小于服务提供的时间。），自己降级处理服务降级超时：8001service1234567891011121314151617181920212223@Servicepublic class PaymentService &#123; public String paymentInfo_OK(Integer id)&#123; return \"线程池：\"+Thread.currentThread().getName()+\"ok\"+id; &#125; // 设置超过 3 秒采用服务降级 @HystrixCommand(fallbackMethod = \"paymentInfo_TimeoutHandler\",commandProperties = &#123; @HystrixProperty(name=\"execution.isolation.thread.timeoutInMilliseconds\",value = \"3000\") &#125;) public String paymentInfo_Timeout(Integer id)&#123; try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return \"线程池：\"+Thread.currentThread().getName()+\"Timeout\"+id; &#125; // 异常后调用的方法 public String paymentInfo_TimeoutHandler(Integer id)&#123; return \"服务超时，调用服务降级成功\"; &#125;&#125; main1@EnableCircuitBreaker 运行异常：8001service123456789101112 @HystrixCommand(fallbackMethod = \"paymentInfo_TimeoutHandler\",commandProperties = &#123; @HystrixProperty(name=\"execution.isolation.thread.timeoutInMilliseconds\",value = \"3000\") &#125;) public String paymentInfo_Timeout(Integer id)&#123; int a = 10/0;// try &#123;// TimeUnit.SECONDS.sleep(5);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; return \"线程池：\"+Thread.currentThread().getName()+\"Timeout\"+id; &#125; 无论是运行异常还是超时都有兜底策略 订单侧：80，先去掉8001的超时和异常==既可以配在客户端也可以配在服务端，一般建议放在客户端== yml 123feign: hystrix: enabled: true controller改为同 8001 的 service 一样 主类添加 @EnableHystrix 注解 注意：降级处理方法参数列表必须跟异常方法一样全面服务降级存在问题 每一个方法都需要配置一个降级方法 和业务代码在一起解决 第一个问题 controller 1234567891011121314151617181920212223242526@RestController@Slf4j// 1. 添加注解，标注全局服务降级方法@DefaultProperties(defaultFallback = \"paymentGlobalFallBack\")public class OrderController &#123; @Resource private PaymentHystrixService service; // 3. 写 @HystrixCommand单不指定具体方法 @GetMapping(\"/ok/&#123;id&#125;\") @HystrixCommand public String paymentInfo_OK(@PathVariable Integer id) &#123; int a = 10/0; return service.paymentInfo_OK(id); &#125; public String paymentInfo_TimeoutHandler(Integer id)&#123; return \"80异常，降级处理\"; &#125; // 2. 定义全局服务降级方法 // 下面是全局 fallback public String paymentGlobalFallBack()&#123; return \"80：获取异常，调用方法为全局fallback\"; &#125;&#125; 第二个问题 找到注解 @FeignClient 对应的接口 再写一个类实现该接口，对降级方法进行处理 123456@Component@FeignClient(value = \"CLOUD-PROVIDER-HYSTRIX-PAYMENT\",fallback = PaymentFallBackService.class)public interface PaymentHystrixService &#123;&#125;@Componentpublic class PaymentFallBackService implements PaymentHystrixService &#123;&#125; 测试在 8001 内加异常，或使 8001 宕机 ，返回异常处理 服务熔断简介类比保险丝，达到最大访问后直接拒绝访问，拉闸限电，然后调用服务降级。当检测==到该节点微服务调用正常后，恢复调用链路。==当失败的调用达到一定阈值，缺省是5s内20次调用失败，就会启动熔断机制。熔断机制的注解是，@HystrixCommand 是什么https://martinfowler.com/bliki/CircuitBreaker.html 实践：8001 service 1234567891011121314151617181920// 服务熔断@HystrixCommand(fallbackMethod = \"paymentInfo_Circuit\",commandProperties = &#123; @HystrixProperty(name=\"circuitBreaker.enabled\",value = \"true\"),//是否开启断路器 @HystrixProperty(name=\"circuitBreaker.requestVolumeThreshold\",value = \"10\"),// 请求次数 @HystrixProperty(name=\"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"),// 时间窗口期 @HystrixProperty(name=\"circuitBreaker.errorThresholdPercentage\",value = \"60\")// 失败率 // 加起来就是在10s内的10次请求中如果失败超过6次进入服务熔断&#125;)public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id)&#123; if (id&lt;0)&#123; throw new RuntimeException(\"id 不能为负数\"); &#125; String serialNumber = IdUtil.simpleUUID(); return \"调用成功：\"+serialNumber;&#125;public String paymentInfo_Circuit(Integer id)&#123; return \"id不能为负数：\"+id;&#125; controller 1234567// 服务熔断@GetMapping(\"/circuit/&#123;id&#125;\")public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id)&#123; String result = paymentService.paymentCircuitBreaker(id); log.info(\"************\"+result); return result;&#125; 结果一直输入id为负数，达到失败率后即使输入id为正数也进入错误页面。 总结熔断类型 熔断打开请求不再进行调用当前服务，内部设有时钟一般为 MTTR，当打开时长达时钟则进入半熔断状态 熔断关闭熔断关闭不会对服务进行熔断 熔断半开根据规则调用当前服务，符合规则恢复正常，关闭熔断什么时候打开设计三个参数：时间窗，请求总阈值，错误百分比阈值 快照时间窗：默认为最近的10s 请求总数阈值：必须满足请求总阈值才有资格熔断。默认为20。意味着在10s内，如果命令调用次数不足20次，即使所有请求都超时或其他原因失败断路器都不会打开 错误百分比阈值：在快照时间窗内请求总数超过阈值，且错误次数占总请求次数的比值大于阈值，断路器将会打开 web界面图形化展示Dashboard搭建 建 moudlecloud-consumer-hystrix-dashboard9001 pom 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; yml只需要配置端口号就行 启动类加注解@EnableHystrixDashboard 测试http://localhost:9001/hystrix有页面即为成功 使用注意 注意：依赖于actuator，要监控哪个接口，哪个接口必须有这个依赖 业务模块需要添加bean123456789@Beanpublic ServletRegistrationBean getServlet()&#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(\"/hystrix.stream\"); registrationBean.setName(\"HystrixMetricsStreamServlet\"); return registrationBean;&#125; 使用 进行8001 的访问查看对应页面变化 页面状态 七色 对应不同状态 一圈 对应访问量 一线 访问趋势","tags":[]},{"title":"9-GetWay","date":"2020-08-13T08:37:58.000Z","path":"2020/08/13/9-GetWay/","text":"概述官网https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.2.RELEASE/reference/html/ 结构 三大核心概念 Route（路由）网关的基本构建块。它由ID，目标URI，谓词集合和过滤器集合定义。如果断言为true，则匹配路由。 Predicate（断言）这是Java 8 Function谓词。输入类型是Spring FrameworkServerWebExchange。这使您可以匹配HTTP请求中的所有内容，例如标头或参数。 Filter（过滤器）这些是使用特定工厂构造的Spring FrameworkGatewayFilter实例。在这里，您可以在发送下游请求之前或之后修改请求和响应。 工作流程 客户端向Spring Cloud Gateway发出请求。如果网关处理程序映射确定请求与路由匹配，则将其发送到网关Web处理程序。该处理程序通过特定于请求的过滤器链来运行请求。筛选器由虚线分隔的原因是，筛选器可以在发送代理请求之前和之后运行逻辑。所有“前置”过滤器逻辑均被执行。然后发出代理请求。发出代理请求后，将运行“后”过滤器逻辑。 实践建模块:cloud-gateway-gateway9527 pom 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 注意不要添加 web的依赖，与gateway里的web flux冲突 --&gt; yml 12345678910111213server: port: 9527spring: application: name: cloud-gatewayeureka: instance: hostname: cloud-gateway-service client: service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka 启动类 123@SpringBootApplication@EnableEurekaClient@EnableDiscoveryClient 测试 9527中配置路由 123456789101112131415spring: application: name: cloud-gateway cloud: gateway: routes: # 可以配置多个路由 - id: payment_routh # 路由id，没有固定规则但要求唯一 uri: http://localhost:8001 # 匹配后提供服务的路由地址 predicates: - Path=/payment/get/** # 路径相匹配的进行路由 - id: payment_routh2 # 路由id，没有 uri: http://localhost:8001 # 匹配后提供服务的路由地址 predicates: - Path=/payment/payment # 路径相匹配的进行路由 配置后可以通过以下路径访问8001中的信息http://localhost:9527/payment/get/31不再暴露8001的端口 配置路由的另一种方法，9527注入 RouteLocator的Bean12345678910111213141516@Configurationpublic class GateWayConfig &#123; @Bean public RouteLocator routeLocator(RouteLocatorBuilder routeLocatorBuilder)&#123; RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes(); /* * 代表访问http://localhost:9527/guonei * 跳转到http://news.baidu.com/guonei * */ routes.route(\"route1\", r-&gt;r.path(\"/guonei\") .uri(\"http://news.baidu.com/guonei\")).build(); return routes.build(); &#125;&#125; 动态路由 9527yml12345678910111213141516171819202122server: port: 9527spring: application: name: cloud-gateway cloud: gateway: discovery: locator: enabled: true # 1.开启从服务在注册中心动态创建路由的功能 routes: - id: payment_routh# uri: http://localhost:8001 # 匹配后提供服务的路由地址 uri: lb://cloud-payment-service # 2.输入服务名，lb代表负载均衡 predicates: - Path=/payment/get/** - id: payment_routh2 # uri: http://localhost:8001 # 匹配后提供服务的路由地址 uri: lb://cloud-payment-service # 2.输入服务名，lb代表负载均衡 predicates: - Path=/payment/create Predicate的使用https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.2.RELEASE/reference/html/#the-between-route-predicate-factory全部在 yml的Predicate之下 After12# 在该时间之后可以使用- After=2020-05-26T17:07:03.043+08:00[Asia/Shanghai] 获取当前时区的时间1ZonedDateTime z = ZonedDateTime.now();// 默认时区 Before 12# 之前- Before=2017-01-20T17:42:47.789-07:00[America/Denver] Between 12# 之间- Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver] Cookie 12# 查看有没有指定kv的cookie- Cookie=username,wxh Header 1# 请求头，跟cookie一样指定kv键值对 Host 1# Method 1# Path 1# Query 1# ReadBodyPredicateFactory 1# RemoteAddr 1# Weight 1# CloudFoundryRouteService 1# 过滤器 Filter单一过滤器https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.2.RELEASE/reference/html/#gatewayfilter-factories 全局过滤器请求头过滤器自定义过滤器 实现接口GlobalFilter,Ordered 能干嘛 全局日志记录 统一网关鉴权 案例1234567891011121314151617181920212223242526@Component@Slf4jpublic class MyLogFilter implements GlobalFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; // 判断有没有 uname 这个参数 log.info(\"自定义全局日志过滤器\"); String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\"); if (uname==null)&#123; log.info(\"用户名非法\"); exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE); return exchange.getResponse().setComplete(); &#125; return chain.filter(exchange); &#125; /* * int HIGHEST_PRECEDENCE = -2147483648; int LOWEST_PRECEDENCE = 2147483647; * 加载过滤器顺序 * 数字越小优先级越高 * */ @Override public int getOrder() &#123; return 0; &#125;&#125;","tags":[]},{"title":"10-Config","date":"2020-08-13T08:37:40.000Z","path":"2020/08/13/10-Config/","text":"概述 分布式系统面临的配置问题每建一个微服务都需要一次配置，例如10个微服务访问相同的数据库，如果数据库名更改了，要改十次。 是什么SpringCloud Config 为微服务架构中的微服务提供几种化的外部配置支持，将不同微服务应用提供一个中心化外部配置。 怎么用服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器 并为客户端提供配置信息。加密解密信息接口。客户端则是通过指定的配置中心来管理应用资源。并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息。这样有助于对环境配置进行版本管理，并且可以通过git客户端方便管理和配置服务内容。将配置信息以REST接口的形式暴露。通过 post curl 刷新 与 github整合服务端配置与整合github 新建仓库springcloud-config 获取新建的地址git@github.com:OT-mt/springcloud-config.git 本地硬盘目录新建 git仓库并clone建模块 pom 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt; yml 12345678910111213141516171819202122server: port: 3344spring: application: name: cloud-config-center cloud: config: server: git: #uri: git@github.com:EiletXie/config-repo.git #Github上的git仓库名字 uri: https://github.com/OT-mt/springcloud-config.git ##搜索目录.这个目录指的是github上的目录 search-paths: - springcloud-config ##读取分支 label: mastereureka: client: service-url: defaultZone: http://eureka7001.com:7001/eureka/ 主启动 123@SpringBootApplication@RestController@EnableConfigServer 测试http://localhost:3344/springcloud-config/blob/master/config-prod.yml 客户端配置与测试 建 moublecloud-config-client3355 pom 12345&lt;!-- 注意与上述不同 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt; yml 123456789```4. 主启动# 客户端动态刷新1. 避免每次更新配置都要更新客户端2. 步骤 1. 添加 actuator 依赖 2. 修改yml暴露端口 3. @RefreshScope业务类controller修饰 4. 刷新 curl -X POST “http://localhost:3355/actuator/refresh&quot; ` 测试","tags":[]},{"title":"11-Bus","date":"2020-08-13T08:37:26.000Z","path":"2020/08/13/11-Bus/","text":"简介是什么？Spring Cloud Bus将分布式系统的节点与轻量级消息代理链接 干什么这可以用于广播状态更改（例如配置更改）或其他管理指令。一个关键的想法是，Bus就像一个扩展的Spring Boot应用程序的分布式执行器，但也可以用作应用程序之间的通信渠道。当前唯一的实现是使用AMQP代理作为传输，但是相同的基本功能集（还有一些取决于传输）在其他传输的路线图上。 官网资料https://www.springcloud.cc/spring-cloud-bus.html 安装 RabbitMQ 下载 ErLanghttps://www.erlang.org/downloads按照默认安装即可 下载RabbitMQ：https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.7/rabbitmq-server-3.7.7.exe按默认安装 进入sbin目录输入命令：rabbitmq-plugins enable rabbitmq_management 进行安装 查看是否安装成功：http://localhost:15672/ 登录 guest guest12345rabbitmq-server -detached 后台启动Rabbitmq-server 直接启动，如果你关闭窗口或者需要在改窗口使用其他命令时应用就会停止 关闭:rabbitmqctl stop 全局广播新建项目 cloud-config-client3366，与3355一样设计思想 利用消息总线触发一个客户端/bus/refresh从而刷新所有客户端配置 利用消息总线触发一个服务端 ConfigServer 的/bus/refresh端点从而刷新所有客户端 明显二更合适 打破了微服务职责单一性 破坏了微服务各节点的对等性 有一定局限性 ，微服务歉意时网络地址常常发生变化实现给cloud-config-center3344 配置中心提供消息总线支持 pom 12345&lt;!-- 添加消息总线RabbitMQ支持 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; yml 123456789101112#rabbitmq配置rabbitmq: host: localhost port: 5672 username: guest password: guest#暴露bus刷新配置端点management: endpoints: web: exposure: include: 'bus-refresh' 给cloud-config-client3355客户端提供消息总线支持 pom 12345&lt;!-- 添加消息总线RabbitMQ支持 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; yml 123456789101112131415spring: application: name: cloud-client cloud: config: label: master name: config profile: dev uri: http://localhost:3344 #rabbitmq配置,注意与服务端不同这个在spring下面 rabbitmq: host: localhost port: 5672 username: guest password: guest 给cloud-config-client3366客户端提供消息总线支持测试 改变github内容 发送post请求： 1curl -X POST &quot;http://localhost:3344/actuator/bus-refresh&quot; 动态刷新定点通知 使用 curl -X POST “http://localhost:配置中心端口号/actuator/bus-refresh/{destination}&quot; 本例中 curl -X POST “http://localhost:3344/actuator/bus-refresh/cloud-client:3355&quot; 代表只通知3355","tags":[]},{"title":"12-Stream","date":"2020-08-13T08:36:47.000Z","path":"2020/08/13/12-Stream/","text":"简介官网https://spring.io/projects/spring-cloud-stream 是什么Spring Cloud Stream是一个框架，用于构建与共享消息传递系统连接的高度可扩展的事件驱动型微服务。 应用程序通过 inputs 和 outputs 来与 Spring Cloud Stream 中的 binder 对象交互。而 Spring Cloud Stream 的 binder 对象负责与消息中间件交互。 ==目前仅支持 RabbitMQ,Kafaka== 解决了什么一个系统中采用多个消息中间件，解决不同消息中间件之间通信的问题。 消息中间件种类 ActiveMQ RabbitMQ RocketMQ Kafka标准MQ 生产者和消费者之间靠消息媒介传递消息内容？Message 消息必须走特定通道？MessageChannel 消息通道里的消息如何被消费？消息通道MessageChannel的子接口SubscribableChanner，由MessageHandler消息处理器所订阅常用注解 @Input注解标识输入通道 @Output注解标识输出通道 @StreamListener监听队列，用于消费者的队列的消息接收 @EnableBindingchannel和exchange绑定在一起实操模块 cloud-stream-rabbitmq-provider8801 pom 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;&lt;/dependency&gt; yml 1234567891011121314151617181920212223242526272829303132server: port: 8801spring: application: name: cloud-stream-provider cloud: stream: binders: #在此配置要绑定的 rabbitmq的服务信息 defaultRabbit: # 表示定义的名称，用于 binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: # 服务的整合处理 output: # 输出通道的名称 destination: studyExchange #表示要使用的 Exchange 名称定义 content-type: application/json # 消息类型 binder: defaultRabbiteureka: client: service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳时间间隔默认30s lease-expiration-duration-in-seconds: 5 # 如果超过了5秒的间隔默认90s instance-id: send-8001.com #信息列表显示主机名称 prefer-ip-address: true # 访问路径变为ip地址 main 12@SpringBootApplication@EnableEurekaClient service 12345678910111213141516171819202122import org.springframework.messaging.MessageChannel;import org.springframework.messaging.support.MessageBuilder;import javax.annotation.Resource;import java.util.UUID;@EnableBinding(Source.class)//定义消息推送管道@Slf4jpublic class IMessageProviderImpl implements IMessageProvider &#123; @Resource private MessageChannel output;//消息发送通道 @Override public String send() &#123; String serial = UUID.randomUUID().toString(); output.send(MessageBuilder.withPayload(serial).build()); log.info(serial+\"***********************\"); return serial; &#125;&#125; controller 12345678910@RestControllerpublic class IMessageController &#123; @Resource private IMessageProvider provider; @GetMapping(\"/sendMessage\") public String send()&#123; return provider.send(); &#125;&#125; 测试 进入rabbitmq 查看Exchanges中有没有studyExchange对应 yml中的自定义名字 多次访问http://localhost:8801/sendMessage 查看rabbitmq 中overview中 Message rates 的折线变化消费者模块 cloud-stream-rabbitmq-consumer8802 pom同8801一样 yml 1234567891011121314151617181920212223242526272829303132server: port: 8802spring: application: name: cloud-stream-consumer cloud: stream: binders: #在此配置要绑定的 rabbitmq的服务信息 defaultRabbit: # 表示定义的名称，用于 binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: # 服务的整合处理 input: # 输出通道的名称 destination: studyExchange #表示要使用的 Exchange 名称定义 content-type: application/json # 消息类型 binder: defaultRabbiteureka: client: service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳时间间隔默认30s lease-expiration-duration-in-seconds: 5 # 如果超过了5秒的间隔默认90s instance-id: receive-8002.com #信息列表显示主机名称 prefer-ip-address: true # 访问路径变为ip地址 main@SpringBootApplication 业务类 12345678910111213@Component@Slf4j@EnableBinding(Sink.class)public class StreamController &#123; @Value(\"$&#123;server.port&#125;\") private String serverPort; @StreamListener(Sink.INPUT) public void input(Message&lt;String&gt;message)&#123; log.info(\"消费者1号接收到消息\"+message.getPayload()+\"\\t port:\"+serverPort); &#125;&#125; 测试 依次启动7001，8801,8802 访问http://localhost:8801/sendMessage 查看8801控制台是否有输出消息重复消费 新建8803，同8802一样 访问http://localhost:8801/sendMessage 8802与8803都可以访问消息 消息分组与持久化消息分组 将两个微服务分到一个组group中，保证消息只能被一个组中的一个应用消费一次，不同的组可以同时消费 配置8802与8803的yml如下123456789spring: application: name: cloud-stream-consumer cloud: stream: binders: #在此配置要绑定的 rabbitmq的服务信息 bindings: # 服务的整合处理 input: # 输出通道的名称 group: group1 # 将 8802与8803分为同一组，这样消息只有一个可以消费 持久化 停掉8802,8803 使用8801发送消息 删除8803的分组 group 启动8803与8802 发现8802可以接受到关闭时发送的消息，而8803不能","tags":[]},{"title":"13-Sleuth","date":"2020-08-13T08:35:18.000Z","path":"2020/08/13/13-Sleuth/","text":"简介官网https://spring.io/projects/spring-cloud-sleuth 监控链路调用这包括将跟踪数据（跨度）报告到的位置，要保留（跟踪）多少个跟踪，是否发送了远程字段（行李）以及要跟踪哪些库。微服务中节点过多，使用它能更好的做监控。 安装Zipkin Sleuth 负责链路监控，Zipkin负责展现 https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/ 下载 exec.jar 使用命令行打开到jar包所在目录java -jar zipkin-server-2.12.9-exec.jar成功后访问http://localhost:9411/ 使用改变最原始的模块80与8001 依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt; yml 12345678spring: zipkin: # 放到 zipkin上 base-url: http://localhost:9411 sleuth: sampler: # 采样率介于0-1之间，1表示全部采集 probability: 1 controller 80 12345@GetMapping(\"/consumer/payment/zipkin\")public String paymentZipkin()&#123; String result = restTemplate.getForObject(PAYMENT_URL+\"/payment/zipkin\",String.class); return result;&#125; controller 8001 1234@GetMapping(\"/payment/zipkin\")public String paymentZipkin()&#123; return \"我是 zipkin\";&#125; 测试依次打开7001,8001,80访问80访问http://localhost:9411/可以查看到访问的链路","tags":[]},{"title":"14-Springcloud-Alibaba简介","date":"2020-08-13T08:35:05.000Z","path":"2020/08/13/14-Springcloud-Alibaba简介/","text":"是什么Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。 依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。 能做什么服务限流降级：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。 服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。 分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。 消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。 分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。。 阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。 分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。 阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。 官网学习资料 spring官网https://spring.io/projects/spring-cloud-alibaba#overview githubhttps://github.com/alibaba/spring-cloud-alibaba 全部参考手册https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html","tags":[]},{"title":"15-Ali-Nacos","date":"2020-08-13T08:34:41.000Z","path":"2020/08/13/15-Ali-Nacos/","text":"简介什么是 NacosDynamic Naming and Configuration Service 动态命名和配置服务Nacos = Eureka+Config+Bus 注册中心与配置中心的组合 能干什么 替代Eureka做注册中心 替代Config做配置中心下载https://github.com/alibaba/nacos官网https://nacos.io/en-us/安装 本案例采用 1.1.4 https://github.com/alibaba/nacos/releases/tag/1.1.4 tar.gz是linux，zip是windows 解压 cmd 进入 bin目录下 startup.cmd 启动程序 进入 http://localhost:8848/nacos 默认账号密码都是 nacos作为服务注册中心服务提供者模块 cloud-ali-provider-payment9001 父 pom 123456789101112&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 子 pom 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; yml 123456789101112131415server: port: 9001spring: application: name: nacos-payment-provider cloud: nacos: server-addr: localhost:8848 # Nacos地址management: endpoints: web: exposure: include: '*' #暴露端口 测试http://localhost:9001/payment/nacos/1进入nocas查看是否配置成功 参照9001新建9002消费者模块==Nacos自带Ribbon实现负载均衡，Nacos支持AP与CP的切换== 新建消费者模块 pom同 9001 一样 yml 1234567891011server: port: 83spring: application: name: nacos-order-consumer cloud: nacos: server-addr: localhost:8848# 消费者要去访问的微服务名称service-url: nacos-user-service: http://nacos-payment-provider 主启动类同 9001 一样 config类 12345678@Configurationpublic class ApplicationContextConfig &#123; @Bean @LoadBalanced public RestTemplate getRestTemplate()&#123; return new RestTemplate(); &#125;&#125; controller 1234567891011121314@RestController@Slf4jpublic class OrderNacosController &#123; @Resource private RestTemplate restTemplate; @Value((\"$&#123;service-url.nacos-user-service&#125;\")) private String serverURL; @GetMapping(value = \"/consumer/payment/nacos/&#123;id&#125;\") public String paymentInfo(@PathVariable(\"id\") Long id)&#123; return restTemplate.getForObject(serverURL+\"/payment/nacos/\"+id,String.class); &#125;&#125; 测试http://localhost:83/consumer/payment/nacos/1 作为配置中心配置 建模块cloud-ali-config-nacos-client3377 pom 12345678&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt; yml：有application与bootstrapapplication 123spring: profiles: active: dev # 表示开发环境 bootstrap12345678910111213server: port: 3377spring: application: name: nacos-config-client cloud: nacos: discovery: server-addr: localhost:8848 # 服务注册中心 config: server-addr: localhost:8848 # 服务注册中心 file-extension: yaml # 指定yaml格式的配置 主启动 12@SpringBootApplication@EnableDiscoveryClient controller 1234567891011@RestController@RefreshScope // 动态刷新public class ConfigClientController &#123; @Value(\"/config.info\") private String configInfo; @GetMapping(\"/config/info\") public String getConfigInfo()&#123; return configInfo; &#125;&#125; 配置dataid ${prefix}-${spring.profile.active}.${file-extension} prefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix来配置。 spring.profile.active 即为当前环境对应的 profile，详情可以参考 Spring Boot文档。 注意：当 spring.profile.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension} file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。 得到 data id为 12$&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125;$&#123;spring-application-name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125; 配置 yaml 文件 测试访问http://localhost:3377/config/info看是否得到配置信息 更改nacos中内容查看3377中是否变化 分组 Nacos默认的命名空间是 public ，Namespace主要实现隔离。比如说现在有三个环境：开发，测试，生产环境，就可以创建三个Namespace，不同的Namespace之间是隔离的。 Group默认是 DEFAULT_GROUP，Group 可以把不同的微服务划分到一个组里去。 service就是微服务，一个微服务可以包含多个 Cluster （集群） Instance就是微服务的实例三种方案加载配置DataID指定 spring.profile.active 与配置文件的DataID来使不同环境下读取不同的配置默认空难攻坚+默认分组+新建dev和test两个DataID Nacos配置中心新建nacos-config-client-test.yaml 将spring中的配置spring.profile.active改成test，就会加载Nacos中新建的yamlGroup Nacos中新建配置 nacos-config-client-info.yaml ,分组为 DEV_GROUP Nacos中新建配置 nacos-config-client-info.yaml ,分组为 TEST_GROUP 将 spring.profile.active改成 info 增加配置 spring.cloud.nacos.config.group 指定组名，选择调用哪个组的文件 测试：http://localhost:3377/config/infoNamespace 找到左侧命名空间，新建test与dev命名空间 dev 命名空间新建 nacos-config-client-dev.yaml 分组为 DEV_GROUP yml文件 123456789spring: application: name: nacos-config-client cloud: nacos: config: # 这个为命名空间的流水号 namespace: 625e1f16-7820-412f-84d0-890d0092577a group: DEV_GROUP 测试：http://localhost:3377/config/info 总结如同包一样 Namespace&gt;Group&gt;DataID Nacos集群与持久化配置（重要）解决问题 如果Nacos挂掉怎么办 Nacos停机了，但是有些数据仍需要保留持久化配置Nacos支持三种部署模式 单机模式 集群模式-用于生产环境 多集群模式-用于多数据中心场景默认Nacos使用嵌入式数据库derby来实现数据的存储。但是如果启动多个默认配置下的Nacos节点，数据存储是存在一致性问题的。为了解决这个问题，Nacos采用集中式存储的方式来支持集群化部署，目前只支持MySQL的存储。环境准备 64 bit OS Linux/Unix/Mac，推荐使用Linux系统。 64 bit JDK 1.8+；下载.配置。 Maven 3.2.x+；下载.配置。 3个或3个以上Nacos节点才能构成集群。 切换数据库 安装数据库，版本要求：5.6.5+ 初始化mysql数据库，数据库初始化文件：nacos\\conf\\nacos-mysql.sql 修改nacos\\conf\\application.properties文件，增加支持mysql数据源配置（目前只支持mysql），添加mysql数据源的url、用户名和密码。 123456spring.datasource.platform=mysqldb.num=1db.url.0=jdbc:mysql://11.162.196.16:3306/nacos_devtest?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true # 更改数据库名,更改127.0.0.1db.user=nacos_devtest #更改用户名db.password=youdontknow #更改密码 重启Nacos 观察到之前写过的配置全部消失，因为切换了数据库集群 前提配置1个Nginx+3个nacos注册中心+1个mysql 下载linux版 下载：https://github.com/alibaba/nacos/releases 解压 同windows一样，需要在linux下设置mysql为nacos持久化存储linux安装mysql 下载：wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.24-linux-glibc2.12-x86_64.tar.gz 将安装包放到指定目录下，解压tar xzvf mysql-5.7.24-linux-glibc2.12-x86_64.tar.gz 移动到 /usr/local目录下https://blog.csdn.net/dc282614966/article/details/81098074 创建 nacos 数据库 source /usr/local/nacos/conf/nacos-mysql.sql 修改nacos\\conf\\application.properties文件，增加支持mysql数据源配置（目前只支持mysql），添加mysql数据源的url、用户名和密码。 123456spring.datasource.platform=mysqldb.num=1db.url.0=jdbc:mysql://11.162.196.16:3306/nacos_devtest?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true # 更改数据库名,更改127.0.0.1db.user=nacos_devtest #更改用户名db.password=youdontknow #更改密码 集群配置 复制nacos/config下的 cluster.config.example 重命名为 cluster.config 修改文件内容,ip地址查看 id addr 123192.168.150.66:3333192.168.150.66:4444192.168.150.66:5555 配置 bin 下的 startup.sh,109集 安装Nginxhttps://blog.csdn.net/t8116189520/article/details/81909574命令： cd /usr/local/nginx/sbin 启动，关闭，重启，命令： ./nginx 启动 ./nginx -s stop 关闭 ./nginx -s reload 重启 配置nginxhttps://www.cnblogs.com/linchenguang/p/12827582.html 注意 关闭防火墙 打开mysql服务 有错误要去nacos的log文件夹内查询 不要将安装包在windows下载后直接拖到linux 测试将idea对应端口换成 nginx 地址即可：192.168.150.66:1111","tags":[]},{"title":"16-Ali-Sentinel","date":"2020-08-13T08:34:18.000Z","path":"2020/08/13/16-Ali-Sentinel/","text":"简介官网https://github.com/alibaba/Sentinel/wiki/%E4%B8%BB%E9%A1%B5 与Hystrix区别Hystrix 需要自己搭建监控平台。 没有一套web界面可以进行更加细粒度的配置，流控，速率控制，服务熔断，服务降级。Sentinel 单独一个组件，可以独立出来 页面化的细粒度统一配置是什么随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 是面向分布式服务架构的流量控制组件，主要以流量为切入点，从限流、流量整形、熔断降级、系统负载保护、热点防护等多个维度来帮助开发者保障微服务的稳定性。能干什么 流量控制 熔断降级 系统自适应保护Sentinel 控制台组件由两部分组成 核心库，jar包，不依赖任何框架，能够运行于所有Java运行的环境。 控制台，基于springboot开发，打包后直接运行，不需要额外的tomcat。安装 https://github.com/alibaba/Sentinel/releases选择sentinel-dashboard-1.7.2.jar 命令行切换到jar包目录 java -jar sentinel-dashboard-1.7.2.jar http://localhost:8080/ 账号密码 sentinel 使用建模块cloud-alibaba-sentinel-service8401 pom 123456789&lt;!-- 后续做持久化用到 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt; yml 1234567891011121314151617181920212223server: port: 8401spring: application: name: cloud-alibaba-sentinel-service cloud: nacos: discovery: # 服务注册中心地址 server-addr: localhost:8848 sentinel: transport: # 配置sentinel dashboard地址 dashboard: localhost:8080 # 默认 8719端口，假如被占用从8719开始+1扫描直到直到未被占用的端口 port: 8719management: endpoints: web: exposure: include: '*' main@SpringBootApplication@EnableDiscoveryClient controller 123456789@GetMapping(\"/testA\")public String testA()&#123; return \"testA\";&#125;@GetMapping(\"/testB\")public String testB()&#123; return \"testB\";&#125; 启动 nacos，sentinel，启动模块 访问模块，观察 sentinel里变化流控规则介绍 资源名：唯一名称，默认请求路径 针对来源：Sentinel可以针对调用者进行限流 ，填写微服务名，默认 default 阈值类型 QPS（每秒请求数量）：当调用api的QPS达到阈值后进行限流 线程数：调用该api的线程数达到阈值后进行限流 是否集群：不需要集群 流控模式： 直接：api达到限流条件时直接限流 关联：当关联的资源达到阈值时就限流自己 链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值就进行限流） 流控效果 快速失败：直接失败，抛异常 Warm Up：根据codeFactor（冷加热因子，默认3）的值，从阈值 codeFactor，经过预热时长，才达到设定的QPS阈值。流控模式 直接 按上图设置QPS为1，然后访问 testA 观察效果 达到阈值快速失败 自定义报错信息关联 关联 testA 与 testB B达到阈值，限流A 使用 postman 模拟并发请求 先访问testB save到新建collection里 选择runner，选择testB，选择迭代次数和等待时长 启动postman，再访问testA查看效果链路 两个入口a，b调用同一个资源，只记录a上的限流，而不关系心b的使用 流控效果直接快速失败（默认）预热 初始QPS = QPS/3 阈值从初始QPS主键增加到 QPS 访问 testB 观察随时间变化错误的数量变化排队等待 为 testB 设置打印当前时间可以观察到一秒一个挨个执行即请求按照顺序依次执行 熔断降级基本介绍 熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。 ==没有半开状态== 触发降级的标准 平均响应时间 (DEGRADE_GRADE_RT)：当 1s 内持续进入 N 个请求，对应时刻的平均响应时间（秒级）均超过阈值（count，以 ms 为单位），那么在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地熔断（抛出 DegradeException）。注意 Sentinel 默认统计的 RT 上限是 4900 ms，超出此阈值的都会算作 4900 ms，若需要变更此上限可以通过启动配置项 -Dcsp.sentinel.statistic.max.rt=xxx 来配置。 异常比例 (DEGRADE_GRADE_EXCEPTION_RATIO)：当资源的每秒请求量 &gt;= N（可配置），并且每秒异常总数占通过量的比值超过阈值（DegradeRule 中的 count）之后，资源进入降级状态，即在接下的时间窗口（DegradeRule 中的 timeWindow，以 s 为单位）之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。 异常数 (DEGRADE_GRADE_EXCEPTION_COUNT)：当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 timeWindow 小于 60s，则结束熔断状态后仍可能再进入熔断状态。 开启平均响应时间 jmeter压力测试每秒10次，永远循环 如何 1s 内持续进了 N 个请求且 平均响应时间均超过阈值，那么下一个窗口期服务熔断 该例中设置个请求 sleep 1s 所以，jmeter 每秒 10次（访问总次数）超过 n=5（默认是5），在下一个时间窗口期内服务熔断异常比例 默认请求量大于5时 异常比例占通过总量和的比例超过阈值时 进入降级状态，且下一个时间窗口期对这个方法调用自动返回异常数 ==将窗口期超过 60s== 模拟异常 10/0 jmeter压测 进入熔断异常 过了时间窗口期，之间不要做任何操作，即可访问 热点参数限流是什么即经常访问的数据 商品id为参数，统计一段时间最常购买的商品 id 并进行限制。 用户id为参数，针对一段时间内频繁访问的用户 id 进行限制。怎么用 controller 12345678910111213@GetMapping(\"/testHotKey\")// 名字可以随意起，但为唯一标识@SentinelResource(value = \"testHotKey\",blockHandler = \"deal_testHotKey\")// required 表示是否必须包含此参数public String testHostKey(@RequestParam(value = \"p1\",required = false) String p1, @RequestParam(value=\"p2\",required = false)String p2)&#123; System.out.println(p1); return \"testHostKey\";&#125;public String deal_testHotKey(String p1, String p2, BlockException exception)&#123; return \"deal_testHotKey\";&#125; 多次访问 http://localhost:8401/testHotKey?p1=a 查看效果,可以生效 多次访问 http://localhost:8401/testHotKey?p1=a&amp;p2=b 查看效果,可以生效 多次访问 http://localhost:8401/testHotKey?p2=a 查看效果,不能生效 多次访问 http://localhost:8401/testHotKey?p2=b&amp;p1=a 查看效果,可以生效 总结上图的参数索引0，对应Java代码参数列表里的参数下标 参数特殊项 当参数为特定值的时候拥有不同的阈值 即使其他参数项熔断，特定参数项也不会熔断 系统自适应限流简介系统保护的目的 保证系统不被拖垮 在系统稳定的前提下，保持系统吞吐量系统保护的问题长期以来系统保护是根据负载来做系统过载保护。当负载超过某个阈值，就禁止或减少流量进入，负载好转后恢复流量进入。 如果根据当前负载的情况调节流量通过率，始终有延迟。这样会浪费系统处理能力。所以看到的曲线总会有所抖动。 恢复慢，下游应用不可靠导致应用 RT 很好，从而负载很高，但过了一段时间下游恢复了，其实应该大幅增加流量通过率。但这时候load仍然很高。通过率恢复仍然不高。==最终目的：在系统不被拖垮的情况下，提高系统的吞吐率，而不是 load 一定要到低于某个阈值==是什么从单台机器的 load、CPU 使用率、平均 RT、入口 QPS 和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。能做什么 Load 自适应（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps minRt 估算得出。设定参考值一般是 CPU cores 2.5。 CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。 平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。 并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。 入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。 怎么做 ==简而言之就是对整个系统添加限流，不推荐使用== SentinelResource 配置兜底方法的两种实现自定义方法123456789101112@RestControllerpublic class RateLimitController &#123; @GetMapping(\"/A\") @SentinelResource(value = \"A\",blockHandler = \"exceptionA\") public String A()&#123; return \"a\"; &#125; public String exceptionA(BlockException e)&#123; return \"exceptionA\"; &#125;&#125; 自定义异常处理类12345@GetMapping(\"/B\")@SentinelResource(value = \"B\",blockHandlerClass = ExceptionHandler.class,blockHandler = \"handler1\")public String B()&#123; return \"B\";&#125; 异常处理类12345678public class ExceptionHandler &#123; public static String handler1(BlockException e)&#123; return \"hanlder1\"; &#125; public static String handler2(BlockException e)&#123; return \"hanlder2\"; &#125;&#125; 服务熔断Ribbon准备提供者模块 cloud-ali-provider-payment9003/9004 pomnacos yml 1234567891011121314server: port: 9003spring: application: name: nacos-payment-provider cloud: nacos: discovery: server-addr: localhost:8848management: endpoints: web: exposure: include: '*' 主启动@SpringBootApplication@EnableDiscoveryClient 业务类1234567891011121314151617@RestControllerpublic class PaymentController &#123; @Value(\"$&#123;server.port&#125;\") private String serverPort; public static HashMap&lt;Long,String&gt; hashMap = new HashMap&lt;&gt;(); static &#123; hashMap.put(1l,\"aaaaaaaaaaaaaa\"); hashMap.put(2l,\"bbbbbbbbbbbbbb\"); hashMap.put(3l,\"cccccccccccccc\"); &#125; @GetMapping(\"/payment/&#123;id&#125;\") public String payment(@PathVariable(\"id\") Long id)&#123; return hashMap.get(id)+serverPort; &#125;&#125; 消费者模块 cloud-ali-consumer-nacos-order84 pom 12345678&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;&lt;/dependency&gt; yml 1234567891011121314151617server: port: 84spring: application: name: nacos-order-consumer cloud: nacos: discovery: server-addr: localhost:8848 sentinel: transport: dashboard: localhost:8080 port: 8719service-url: nacos-user-service: http://nacos-payment-provider main@SpringBootApplication@EnableDiscoveryClient config配置RestTemplate controller12345678910111213141516171819@RestControllerpublic class CircleBreakerController &#123; public static final String SERVICE_URL = \"http://nacos-payment-provider\"; @Resource private RestTemplate restTemplate; @RequestMapping(\"/consumer/fallback/&#123;id&#125;\") @SentinelResource(value = \"fallback\") public String fallback(@PathVariable(\"id\") Long id)&#123; String result = restTemplate.getForObject(SERVICE_URL+\"/payment/\"+id,String.class,id); if (id==4)&#123; throw new RuntimeException(\"非法参数异常\"); &#125; return result; &#125;&#125; 使用配置fallback 改变 84 中的 controller 123456789101112131415161718192021222324@RestControllerpublic class CircleBreakerController &#123; public static final String SERVICE_URL = \"http://nacos-payment-provider\"; @Resource private RestTemplate restTemplate; @RequestMapping(\"/consumer/fallback/&#123;id&#125;\")// @SentinelResource(value = \"fallback\") // 没有配置 @SentinelResource(value = \"fallback\",fallback = \"handlerFallback\") public String fallback(@PathVariable(\"id\") Long id)&#123; String result = restTemplate.getForObject(SERVICE_URL+\"/payment/\"+id,String.class,id); if (id==4)&#123; throw new RuntimeException(\"非法参数异常\"); &#125; return result; &#125; public String handlerFallback(@PathVariable Long id)&#123; return id+\"异常\"; &#125;&#125; 访问 84 输入 id=4 模拟异常 有异常时进入fallback，其实就是兜底方法 配置 blockHanlder 改变 84 中的controller 123456789101112131415161718192021 @RequestMapping(\"/consumer/fallback/&#123;id&#125;\")// @SentinelResource(value = \"fallback\") // 没有配置// @SentinelResource(value = \"fallback\",fallback = \"handlerFallback\") @SentinelResource(value = \"fallback\",blockHandler = \"blockHandler\") public String fallback(@PathVariable(\"id\") Long id)&#123; String result = restTemplate.getForObject(SERVICE_URL+\"/payment/\"+id,String.class,id); if (id==4)&#123; throw new RuntimeException(\"非法参数异常\"); &#125; return result; &#125;// public String handlerFallback(@PathVariable Long id)&#123;// return id+\"异常\";// &#125; public String blockHandler(Long id, BlockException e)&#123; return \"blockHandler异常\"; &#125; 访问 84 输入 id=4 模拟异常 结果==没有在sentinel中配置服务降级只会报出异常界面，而fallback不需要配置sentinel== 再测试配置异常数为 2 ，单独点 1 次 爆异常界面，连续两次爆blockhandler的方法 配置fallback+blockHanlder未进入限流条件进 fallback，进入限流条件进 blockhandler 异常忽略@SentinelResource(value = &quot;fallback&quot;,fallback = &quot;handlerFallback&quot;,blockHandler = &quot;blockHandler&quot;,exceptionsToIgnore = RuntimeException.class)忽略某种类型的异常 服务熔断OpenFeign更改84 pom 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; yml 123feign: sentinel: enabled: true main@EnableFeignClients 新建service 12345@FeignClient(value = \"nacos-payment-provider\",fallback = PaymentFailService.class)public interface PaymentService &#123; @GetMapping(\"/payment/&#123;id&#125;\") public String payment(@PathVariable(\"id\") Long id);&#125; 新建service兜底类 1234567@Componentpublic class PaymentFailService implements PaymentService &#123; @Override public String payment(Long id) &#123; return \"feign失败调用\"; &#125;&#125; 更改controller 123456@Resourceprivate PaymentService paymentService;@GetMapping(\"consumer/payment/&#123;id&#125;\")public String payment(@PathVariable(\"id\") Long id)&#123; return paymentService.payment(id);&#125; 测试关闭 9003,9004 访问 84 查看是否进入兜底方案 持久化 简介存到nacos中 pom 12345&lt;!-- 后续做持久化用到 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt; &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt; &lt;/dependency&gt; yml 1234567891011spring: cloud: sentinel: datasource: ds1: nacos: server-addr: localhost:8848 #nacos地址 dataId: cloud-alibaba-sentinel-service #微服务名称 groupId: DEFAULT_GROUP #默认分组 data-type: json #数据格式 rule-type: flow #流控规则 nocos 8848 中新增配置 1234567891011[ &#123; \"resource\":\"/A\",//资源名称 \"limitApp\":\"default\",//来源应用 \"grade\":1,//阈值类型，0线程数，1QPS \"count\":1,//单机阈值 \"strategy\":0,//流控模式，0表示直接，1表示关联，2表示链路 \"controlBehavior\":0,//流控效果 ，0表示快速失败，1表示warm up，2表示排队等待 \"clusterMode\":false //是否集群 &#125;] 重启8401，刷新sentinel查看效果","tags":[]},{"title":"17-Ali-Seata","date":"2020-08-13T08:32:28.000Z","path":"2020/08/13/17-Ali-Seata/","text":"简介解决问题 分布式前Java服务与数据库1-&gt;1 分布式后 1-&gt;1,1&gt;多,多-&gt;多保证多个服务之间的数据一致性是什么Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。官网http://seata.io/zh-cn/处理过程 一ID+三组件 id全局唯一的事务ID 3组件 TC - 事务协调者维护全局和分支事务的状态，驱动全局事务提交或回滚。 TM - 事务管理器定义全局事务的范围：开始全局事务、提交或回滚全局事务。 RM - 资源管理器管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。处理过程 TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID XID在微服务调用链路的上下文中传播 RM向TC注册分支事务，将其纳入XID对应全局事务的管辖 TM 向 TC 发起针对 XID 的全局提交或回滚请求 TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求 安装 下载https://github.com/seata/seata/releases 找到conf下的 file.conf将 mode 改为 db代表将日志存储到数据库修改数据库账号密码端口找到 register.conf将 registry 与 config 里的 type均改为nacos同时修改两者下面的 nacos信息 创建数据库 seata 数据库加载文件 查看RANDME.MD server 对应网址即可 https://github.com/seata/seata/tree/develop/script/client下db中的mysql 实验数据库 创建数据库 create database seata_order;订单 create database seata_storage;库存 create database seata_account;账户信息 建表 seata_order下建t_order seata_storage下建 t_storage; seata_account下建 t_account 建表sql12345678create table t_order( id bigint(11) not null auto_increment primary key, user_id bigint(11) default null comment '用户id', product_id bigint(11) default null comment '产品id', count int(11) default null comment '数量', money decimal(11,0) default null comment '余额', status int(1) default null comment '订单状态') 建模块seata-order-service2001 pom123456789101112131415161718192021&lt;!-- seata --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-seata&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- 引入与自己版本相同的 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-all&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; ########################## 依赖 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- 引入与自己版本相同的 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt;&lt;/dependency&gt; yml config.txt nacos-config.sh 上传配置","tags":[]},{"title":"18-Seata配置","date":"2020-08-13T08:30:41.000Z","path":"2020/08/13/18-Seata配置/","text":"本例使用seata1.2 创建seata数据库 找到 seata/conf 下的 README-zh.md 进入 server 找到 db 下的 mysql.sql 创建数据库 seata ，后执行mysql.sql mysql.sql中的三张表为 seata配置必须的表 创建业务必须数据库用以做案例1234567891011121314151617181920212223242526-- 建数据库，订单create database seata_order;use seata_order;-- 建订单表CREATE TABLE `t_order` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(50) NULL DEFAULT NULL, PRIMARY KEY (`id`))COLLATE='utf8_general_ci'ENGINE=InnoDBAUTO_INCREMENT=8;-- 建数据库，库存create database seata_storage;-- 建库存表CREATE TABLE `t_storage` ( `id` INT(11) NOT NULL, `num` INT(11) NOT NULL, PRIMARY KEY (`id`))COLLATE='utf8_general_ci'ENGINE=InnoDB;-- 初始化库存数量insert into t_storage values(1,20); 找到 seata/conf 下的 README-zh.md 进入 client 找到db下的mysql.sqlclient 其中为一建表sql ==每一个分布式业务数据库都需要这张表，即在新建的数据库 seata_order 与 seata_storage中新建该表==修改seata1.2 找到 seata/conf/file.conf将 store 下的 mode 改为 db ，代表采用数据库配置更改 store下数据库的相关配置 找到 seata/conf/registry.conf将 type 改为 nacos 同时修改 nacos中的信息和config下nacos的信息1234567891011121314151617181920212223242526registry &#123; # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa type = &quot;nacos&quot; nacos &#123; application = &quot;seata-server&quot; serverAddr = &quot;localhost:8848&quot; namespace = &quot;&quot; cluster = &quot;default&quot; username = &quot;nacos&quot; password = &quot;nacos&quot; &#125;&#125;config &#123; # file、nacos 、apollo、zk、consul、etcd3 type = &quot;nacos&quot; nacos &#123; serverAddr = &quot;localhost:8848&quot; namespace = &quot;&quot; group = &quot;SEATA_GROUP&quot; username = &quot;nacos&quot; password = &quot;nacos&quot; &#125;&#125; 为nacos添加配置信息 访问 config-center 将 config.txt 拷贝到 seata/下 修改config.txt内容为下列，因为其余配置为默认或无用配置 123456789101112131415service.vgroupMapping.my_test_tx_group=defaultstore.mode=dbstore.db.datasource=druidstore.db.dbType=mysqlstore.db.driverClassName=com.mysql.jdbc.Driverstore.db.url=jdbc:mysql://127.0.0.1:3306/seata?useUnicode=truestore.db.user=rootstore.db.password=rootstore.db.minConn=5store.db.maxConn=30store.db.globalTable=global_tablestore.db.branchTable=branch_tablestore.db.queryLimit=100store.db.lockTable=lock_tablestore.db.maxWait=5000 将 nacos 下的 nacos-config.sh 拷贝到 seata/conf/ 下 启动nacos 使用 Git Bash Here 切换到 seata/conf/ 下执行命令sh nacos-config.sh 查看nacos中是否有 seata 相关的配置信息。配置业务seata-order-service2001 pom 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;dependencies&gt; &lt;!--引入自己的公共api--&gt; &lt;dependency&gt; &lt;groupId&gt;com.wxh.springcloud&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--热部署--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 使用openfeign做微服务调用 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!-- 引入与自己版本相同的 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.seata&lt;/groupId&gt; &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; yml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 端口号server: port: 2001spring: application: name: seata-order-service cloud: nacos: discovery: #Nacos注册中心地址 server-addr: localhost:8848 datasource: type: com.alibaba.druid.pool.DruidDataSource #数据源类型 driver-class-name: org.gjt.mm.mysql.Driver #mysql驱动包 url: jdbc:mysql://localhost:3306/seata_order?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false username: root password: rootfeign: hystrix: enabled: truelogging: level: io: seata: infomybatis: mapper-locations: classpath:mapper/*.xmlseata: enabled: true # 应用 id 为唯一便于区分 application-id: order # 事务分组，这个是默认分组 tx-service-group: my_test_tx_group config: type: nacos nacos: namespace: serverAddr: 127.0.0.1:8848 group: SEATA_GROUP userName: \"nacos\" password: \"nacos\" registry: type: nacos nacos: application: seata-server server-addr: 127.0.0.1:8848 namespace: userName: \"nacos\" password: \"nacos\" mapper 123456@Mapperpublic interface OrderMapper &#123; // 插入一条订单 @Insert(\"insert into t_order values(null,'test')\") public void test();&#125; service：接口类省略 12345678910111213141516@Servicepublic class OrderServiceImpl implements OrderService &#123; @Resource OrderMapper orderMapper; @Resource StroageService stroageService; @Override // name对应配置文件里的事务分组 @GlobalTransactional(name = \"my_test_tx_group\",rollbackFor = Exception.class) public void test() &#123; orderMapper.test(); stroageService.test(); &#125;&#125; StorageService.java 12345@FeignClient(value = \"seata-storage-service\")public interface StroageService &#123; @RequestMapping(\"/test\") public String test();&#125; controller 1234567@Resourceprivate OrderService orderService;@RequestMapping(\"/test\")public String test()&#123; orderService.test(); return \"test\";&#125; 配置业务模块seata-storage-service2003 pom 与上一模块相同 yml 与上一模块相同 更改端口号 更改spring.application.name. 更改seata.application-id: storage 为了方便省去service由controller直接调用mapper mapper 123456@Mapperpublic interface StorageMapper &#123; // 代表库存减1 @Update(\"UPDATE t_storage SET num = num-1 WHERE id = 1\") public void test();&#125; controller 1234567891011121314@RestControllerpublic class StorageController &#123; @Resource StorageMapper storageMapper; @RequestMapping(\"/test\") public String test()&#123; // int a = 1/0; // 模拟异常 storageMapper.test(); return \"storage\"; &#125;&#125; 测试 正常启动两个模块 访问http://localhost:2001/test查看是否能成功访问 启动模拟异常 将模块 seata-order-service2001 中 OrderServiceImpl.class 下的 stroageService.test();打上断点 debug 启动seata-order-service2001 访问 http://localhost:2001/test 此时进入断点 查看 t_order 表中新增一条数据，数据库中 seata_order 下的 undo_log 表中增加信息，代表事务 数据库 seata_order 的 undo_log 表中添加事务信息 结束执行代码 t_order 表中数据消失 数据库 seata_order 的 undo_log 表数据消失 测试成功 修改事务分组 yml中seata:tx-service-group: test nacos中新增配置service.vgroupMapping.test内容为 default service.vgroupMapping.test 的值为集群名称，test即事务分组 ，default代表无集群","tags":[]},{"title":"使用hexo编写自己的博客","date":"2018-08-13T07:49:10.000Z","path":"2018/08/13/使用hexo编写自己的博客/","text":"#使用hexo编写自己的博客 ##一、安装必要的软件1、安装nodejs 2、安装Git 3、使用npm安装Hexo: $npm install -g hexo-cli ##二、快速搭建博客1、初始化hexo仓库，选择一个目录作为你编写博客的根目录，cd到该目录。 $hexo init 2、初始化博客空间，生成博客运作所需要的文件，接下来安装依赖包。 $npm install 3、发表第一篇文章，在hexo根目录下，创建文章。 $hexo new “我的第一篇文章”，这样就会在博客目录下source_posts中生成相应的 我的第一篇文章.md文件(例如 C:\\blog\\source_posts\\我的第一篇文章.md)。 4、使用markdown语法编写source_posts中生成的”我的第一篇文章.md”。 5、清除之前编译好的缓存 $hexo clean 6、生成对应的组件和文章 $hexo generate 7、启动本地服务器查看效果http://localhost:4000。 $hexo server 8、在github上建立一个仓库，名字设为 “github名字.github.io“ 9、修改hexo站点的配置文件，打开_congfig.yml，修改github地址，例如 deploy: type: git repo: https://github.com/zzStore/zzStore.github.io branch: master 10、上传编写好的博客至github上。$hexo deploy ##三、登录到刚才编写好的博客上“github名字.github.io“","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]